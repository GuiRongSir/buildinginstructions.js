<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8" />
    <title>Sample Building Instructions</title>
    <link href="css/instructions.css" rel="stylesheet" type="text/css" />
    <link href="css/preview.css" rel="stylesheet" type="text/css">
    <link href="css/buttons.css" rel="stylesheet" type="text/css" />
    <link href="css/options.css" rel="stylesheet" type="text/css" />
    <!--<meta name="viewport" content="width=device-width" />-->
  </head>
  <body>
    <div id="pli_render_canvas"></div>
    <script src="js/jquery.min.js"></script>
    <script src="js/three.min.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/colors.js"></script>
    <script src="js/LDRShaders.js"></script>    
    <script src="js/LDRColorMaterials.js"></script>
    <script src="js/pli.js"></script>
    <script src="js/LDRSVG.js"></script>
    <script src="js/LDROptions.js"></script>
    <script src="js/LDRGeometries.js"></script>
    <script src="js/LDRLoader.js"></script>
    <script src="js/LDRStepBuilder.js"></script>
    <script src="js/LDRPartsBuilder.js"></script>
    <script src="js/RectanglePacking.js"></script>
    <script src="js/LDRPLIBuilder.js"></script>
    <script src="js/LDRPLIPreview.js"></script>
    <script src="js/LDRButtons.js"></script>
    <script src="js/LDRMeasurer.js"></script>
    <canvas id="main_canvas"></canvas>
    <script>
      var modelTypeUrl = 'models/fail1.mpd';
      //var modelTypeUrl = 'models/spiral.ldr';
      var scene = new THREE.Scene(); // To add stuff to
      scene.background = new THREE.Color( 0xffffff );

      var defaultZoom = 1; // Will be overwritten.
      var currentStep = 1;
      var camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 1000000 ); // Orthographics for LEGO
      var pliW = 0, pliH = 0;
      var maxSizePerPixel = 1;

      function setBackgroundColor(c) {
        scene.background = new THREE.Color( parseInt("0x" + c) );
	document.body.style.backgroundColor = '#' + c;
      }

      var canvas = document.getElementById('main_canvas');
      var renderer = new THREE.WebGLRenderer({antialias: true, canvas:canvas});
      function render() {
        renderer.render(scene, camera);
      }
      document.body.appendChild(canvas);
      LDR.Colors.canBeOld = true;
      var ldrOptions = new LDR.Options();
      var ldrButtons = new LDR.Buttons(document.body, true, '1', null);
      var controls = new THREE.OrbitControls(camera, canvas);
      controls.noTriggerSize = 0.1;
      controls.addEventListener('change',render);

      function resetCameraPosition() {
	camera.lookAt(new THREE.Vector3());
        updateViewPort();
        updateCameraZoom();
	render();
      }
      function zoomIn() {
        controls.dollyIn(1.2);
	render();
      }
      function zoomOut() {
        controls.dollyOut(1.2);
	render();
      }
      function updateCameraZoom(zoom) {
        zoom = zoom || defaultZoom;
	camera.zoom = zoom;
    	camera.updateProjectionMatrix();
      }

      resetCameraPosition();
      window.addEventListener('resize', onWindowResize, false);

      function onWindowResize(){
        console.log("Resizing to " + window.innerWidth + ", " + window.innerHeight + " and device pixel ratio: " + window.devicePixelRatio);
        renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(window.innerWidth-20, window.innerHeight);
        camera.left   = -canvas.clientWidth*0.95;
        camera.right  =  canvas.clientWidth*0.95;
        camera.top    =  canvas.clientHeight*0.95;
        camera.bottom = -canvas.clientHeight*0.95;
	
	updateViewPort();
        updateCameraZoom();
	if(builder) {
	  realignModel(0);
	  updateUIComponents(false);
	}
      }

      var currentRotationMatrix = new THREE.Matrix4(); 
      currentRotationMatrix.set(1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1);
      var defaultMatrix = new THREE.Matrix4();
      defaultMatrix.set(1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1);

      var ldrLoader;
      var builder = null;
      var pliElement;
      var pliClickMap; // All active pli's {pc, x, y, w, h}
      var pliBuilder;
      var pliShownPreview;

      var baseObject = new THREE.Group(), opaqueObject = new THREE.Group(), transObject = new THREE.Group();
      baseObject.add(opaqueObject); // Draw non-trans before trans.
      baseObject.add(transObject);
      scene.add(baseObject);
      var pliPreviewer = new LDR.PliPreviewer();

      var showPLI = false;
      function updateUIComponents(force) {
      	  currentMultiplier = builder.getMultiplierOfCurrentStep();
      	  currentRotation = builder.getRotationOfCurrentStep();
	  updateMultiplier && updateMultiplier();
	  updateRotator && updateRotator();
	  setBackgroundColor(builder.getBackgroundColorOfCurrentStep());
	  if(builder.isAtVeryLastStep()) {
	    ldrButtons.atLastStep();
	  }
	  else if(builder.isAtFirstStep()) {
	    ldrButtons.atFirstStep();
	  }
  	  else {
	    ldrButtons.atAnyOtherStep();
	  }
	  ldrButtons.setShownStep(currentStep);
	  updatePLI(force);
          updateViewPort();
          updateCameraZoom();
	  render();
      }
      function updatePLI(force) {
	  var [step,stepColorID] = builder.getCurrentStepAndColor();
	  showPLI = ldrOptions.showPLI && step.containsPartSubModels(ldrLoader);
	  if(!showPLI) {
	    pliBuilder.pliElement.style.visibility = 'hidden';
	    pliW = pliH = 0;
	    return;
	  }
	  pliBuilder.pliElement.style.visibility = 'visible';

	  var maxWidth = window.innerWidth/window.devicePixelRatio;
	  var maxHeight = (window.innerHeight - 320)/window.devicePixelRatio; // icons, mult and rotator.

	  if(maxWidth >= maxHeight) {
	    pliClickMap = pliBuilder.drawPLIForStep(true, step, stepColorID, maxWidth*0.4, maxHeight, maxSizePerPixel*0.6, force);
	  }
	  else {
	    pliClickMap = pliBuilder.drawPLIForStep(false, step, stepColorID, maxWidth, maxHeight*0.4, maxSizePerPixel*0.6, force);
	  }
	  pliW = parseInt(pliElement.offsetWidth + pliElement.offsetLeft)+4; // 4 for border.
	  pliH = parseInt(pliElement.offsetHeight);
	  //console.log("Setting PLI size " + pliW + ", " + pliH + " from " + maxWidth + "/" + maxHeight + ", maxSizePerPixel=" + maxSizePerPixel);
      }
      function updateViewPort() {
          camera.position.set(10000, 7000, 10000);

	  if(pliBuilder && pliBuilder.fillHeight) {
	      controls.panTo(pliW/2, -30);
	  }
	  else {
	      controls.panTo(0, pliH/2 + (pliH > 0 ? 25 : 0));
	  }
      }

      var currentMultiplier = 1;
      var currentRotation = false;
      var updateMultiplier = null;
      var updateRotator = null;
      var initialConfiguration = true;
      function realignModel(stepDiff, onRotated, onDone) {
	  var oldRotationMatrix = currentRotationMatrix;
	  var oldPosition = new THREE.Vector3();
	  oldPosition.copy(baseObject.position);

	  // PLI:
	  var oldPLIW = pliW;
	  var oldPLIH = pliH;
	  var newPLIW, newPLIH;

	  var oldLevel = builder.getLevelOfCurrentStep();
	  var newLevel = oldLevel;
	  var goBack = function(){}; // Used for single steps
	  if(stepDiff === 1 && builder.nextStep(true)) {
	      goBack = function() {
	        newLevel = builder.getLevelOfCurrentStep();
	        builder.prevStep(true);
              };
	  }
	  else if(stepDiff === -1 && builder.prevStep(true)) {
	      goBack = function() {
	        newLevel = builder.getLevelOfCurrentStep();
	        builder.nextStep(true);
	      };
	  }

	  var viewPortWidth = window.innerWidth;
	  var viewPortHeight = window.innerHeight;
	  if(pliBuilder.fillHeight) {
	    viewPortWidth *= 0.6;
	    viewPortHeight -= 100;
	  }
	  else {
	    viewPortHeight *= 0.6;
	    viewPortHeight -= 160;
	  }

	  var useAccumulatedBounds = true;
	  var b = builder.getAccumulatedBounds();
	  var size = b.min.distanceTo(b.max);
	  var viewPortSize = Math.sqrt(viewPortWidth*viewPortWidth + viewPortHeight*viewPortHeight);
          //console.log("size=" + size + ", screen size=" + viewPortSize + ", size/screen=" + (size/viewPortSize));
	  if(size > viewPortSize) {
	    useAccumulatedBounds = false;
	    b = builder.getBounds();
	    size = b.min.distanceTo(b.max);
	  }
          var newPosition;
	  [newPosition, currentRotationMatrix] = builder.computeCameraPositionRotation(defaultMatrix, currentRotationMatrix, useAccumulatedBounds);

	  // Find actual screen bounds:
	  baseObject.setRotationFromMatrix(currentRotationMatrix);
	  baseObject.updateMatrixWorld(true);
	  var measurer = new LDR.Measurer(camera);
	  var [dx,dy] = measurer.measure(b, baseObject.matrixWorld);

	  // Update maxSizePerPixel:
	  if(dx*window.innerWidth/viewPortWidth > dy*window.innerHeight/viewPortHeight) {
	    maxSizePerPixel = size/viewPortWidth;
	  }
	  else {
	    maxSizePerPixel = size/viewPortHeight;
	  }
	  updatePLI(false); newPLIW = pliW, newPLIH = pliH;

	  goBack();
	  var rotationChanges = !currentRotationMatrix.equals(oldRotationMatrix);
	  var ignorePos = new THREE.Vector3(); // Ignore
	  var newRot = new THREE.Quaternion();
	  var ignoreScale = new THREE.Vector3(); // Ignore
	  currentRotationMatrix.decompose(ignorePos, newRot, ignoreScale);

	  var positionChanges = !oldPosition.equals(newPosition) || 
	      		      	oldPLIW !== newPLIW || oldPLIH !== newPLIH;

	  var oldDefaultZoom = defaultZoom;
	  viewPortWidth = window.innerWidth;
	  viewPortHeight = window.innerHeight;
	  if(pliBuilder.fillHeight) {
	    viewPortWidth -= newPLIW;
	    viewPortHeight -= 100;
	  }
	  else {
	    viewPortHeight -= newPLIH+160;
	  }
	  var scaleX = window.innerWidth / viewPortWidth * 1.1; // 1.1 to scale down a bit
	  var scaleY = window.innerHeight / viewPortHeight * 1.1;
	  if(dx*scaleX > dy*scaleY) {
	    defaultZoom = 2*camera.zoom/(dx*scaleX);
	  }
	  else {
	    defaultZoom = 2*camera.zoom/(dy*scaleY);
	  }
	  var newDefaultZoom = defaultZoom;
	  var zoomChanges = oldDefaultZoom !== newDefaultZoom;

	  function finalize() {
	      initialConfiguration = false;
	      onRotated && onRotated(); onRotated = false;
    	      
	      baseObject.setRotationFromMatrix(currentRotationMatrix);
    	      baseObject.position.x = newPosition.x;
    	      baseObject.position.y = newPosition.y;
    	      baseObject.position.z = newPosition.z;
	      
	      updateCameraZoom();
	      render();
	      onDone && onDone(); onDone = false;
	  }
	  
	  var animationID;
	  var startTime = new Date();
	  var animationTimeRotationMS = rotationChanges ? (2-ldrOptions.showStepRotationAnimations)*300 : 0; // First rotate, 
	  var animationTimePositionMS = positionChanges ? (2-ldrOptions.showStepRotationAnimations)*150 : 0; // then move and zoom
	  if(stepDiff != 0 && newLevel !== oldLevel && newLevel-oldLevel === stepDiff) {
            animationTimeRotationMS = 0; // Don't rotate when stepping in.
	    animationTimePositionMS = 0;
	  }
	  var animationTimeMS = animationTimePositionMS+animationTimeRotationMS;
	  var lastPosition = oldPosition;
	  function animate() {
	      animationID = requestAnimationFrame(animate);

	      var diffMS = new Date() - startTime;
	      if(diffMS >= animationTimeMS) {
	          cancelAnimationFrame(animationID); 
		  finalize();
		  return; // Done.
	      }

	      var progress = diffMS / animationTimeMS;
	      defaultZoom = oldDefaultZoom + (newDefaultZoom-oldDefaultZoom)*progress;
	      pliW = oldPLIW + (newPLIW-oldPLIW)*progress;
	      pliH = oldPLIH + (newPLIH-oldPLIH)*progress;
	      updateViewPort();
	      updateCameraZoom();

	      if(diffMS < animationTimeRotationMS) { // Rotate first.
		  progress = diffMS/animationTimeRotationMS;

		  var oldPos = new THREE.Vector3();
		  var oldRot = new THREE.Quaternion();
		  var oldScale = new THREE.Vector3();
		  oldRotationMatrix.decompose(oldPos, oldRot, oldScale);
		  var angleToTurn = oldRot.angleTo(newRot);
		  oldRot.rotateTowards(newRot, angleToTurn*progress*1.1); // *1.1 Ensure it is fully turned.
		  
		  var invOldM4 = new THREE.Matrix4();
		  invOldM4.getInverse(oldRotationMatrix);
		  var tmpM4 = new THREE.Matrix4();
		  tmpM4.compose(oldPos, oldRot, oldScale);

		  oldPos.copy(oldPosition);
		  oldPos.negate();
		  oldPos.applyMatrix4(invOldM4);
		  oldPos.applyMatrix4(tmpM4);
		  oldPos.negate();
		  lastPosition = oldPos;
		  
    		  baseObject.setRotationFromMatrix(tmpM4);
    		  baseObject.position.x = oldPos.x;
    		  baseObject.position.y = oldPos.y;
    		  baseObject.position.z = oldPos.z;
	      }
	      else { // Move and zoom:
		  onRotated && onRotated(); onRotated = false;
		  progress = (diffMS-animationTimeRotationMS)/animationTimePositionMS;

		  var tmpPosition = new THREE.Vector3();
		  tmpPosition.subVectors(newPosition, lastPosition).multiplyScalar(progress).add(lastPosition);
		  
		  // Update camera and baseObject:
    		  baseObject.position.x = tmpPosition.x;
    		  baseObject.position.y = tmpPosition.y;
    		  baseObject.position.z = tmpPosition.z;
	      }

	      render();
          }

	  // Only animate if:
	  if(ldrOptions.showStepRotationAnimations < 2 && // show animations
	     Math.abs(stepDiff) === 1 && // Only stepping a single step &&
	     !initialConfiguration && // This is not the initial step &&
	     (zoomChanges || rotationChanges || positionChanges)) {
	    animate();
	  }
	  else {
	    finalize();
	  }
      }

      function clampStep(s) {
        if(s < 1)
	  return 1;
	if(s > builder.totalNumberOfSteps)
	  return builder.totalNumberOfSteps;
	return s;
      }

      var handleStepsWalked = function(walkedSteps) {
        currentStep = clampStep(currentStep + walkedSteps);
	if(walkedSteps != 1 && walkedSteps != -1)
          realignModel(0);
  	updateUIComponents(false);
	render();
      };
      function goToStep(step) {
        if(pliShownPreview)
	  return; // Don't walk when showing stuff.

	step = clampStep(step);
	var diff = step-currentStep;
	console.log("Going to " + step + " from " + currentStep);
	builder.moveSteps(step-currentStep, handleStepsWalked);
      }

      function nextStep() {
        if(pliShownPreview)
	  return; // Don't walk when showing stuff.
        if(builder.isAtVeryLastStep())
	  return;

	realignModel(1, function(){
            builder.nextStep(false);	      
	}, function() {
	    handleStepsWalked(1, false);
	});
      }
      function prevStep() {
        if(pliShownPreview)
	  return; // Don't walk when showing stuff.
	if(builder.isAtFirstStep())
	  return;

	realignModel(-1, function(){
          builder.prevStep(false);
	}, function() {
	  handleStepsWalked(-1, false);
	});
      }

      // Make ldrButtons catch arrow keys left/right
      document.onkeydown = handleKeyDown;
      function handleKeyDown(e) {
          e = e || window.event;
	  if(e.altKey) {
	    // Don't handle key events when ALT is pressed, as they indicate page shift overwrite!
	    return;
	  }
	  if(e.keyCode == '13') { // ENTER
	    var stepToGoTo = parseInt(ldrButtons.stepInput.value);
	    goToStep(stepToGoTo);
	  }
	  else if(e.keyCode == '37') { // Left:
	    prevStep();
          }
	  else if (e.keyCode == '39') { // Right:
            nextStep();
          }
	  else if(e.keyCode == '27') { // ESC closes preview.
	    hidePliPreview();
          }
      }
      
      function hidePliPreview() {
	    pliPreviewer.hidePliPreview();
	    pliPreviewer.scene.remove(pliShownPreview);
	    pliShownPreview = null;
      }
	
      var onLoad = function() {
	var geometryBuilder = new LDR.GeometryBuilder(ldrLoader, {});
	var toBeBuilt = geometryBuilder.getAllTopLevelToBeBuilt();
	geometryBuilder.build(toBeBuilt);

	var mainModel = ldrLoader.mainModel;
	var origo = new THREE.Vector3();
	var inv = new THREE.Matrix3(); 
      	inv.set(1,0,0, 0,1,0, 0,0,1); // Invert Y-axis

	var pd = new THREE.LDRPartDescription(0, origo, inv, mainModel, false);

	pliElement = document.getElementById('pli');
	pliBuilder = new LDR.PLIBuilder(ldrLoader,
		     	                mainModel,
					0, 
		                        pliElement,
					document.getElementById('pli_render_canvas'));
        builder = new LDR.StepBuilder(opaqueObject, transObject, ldrLoader, [pd], function(){render();}, true);
	builder.nextStep(false);
	realignModel(0);
	updateUIComponents(false);
	render(); // Updates background color.

	// Enable pli preview:
        pliPreviewer.attachRenderer(document.getElementById('preview'));
      }

      onWindowResize();
      ldrLoader = new THREE.LDRLoader(onLoad);
      ldrLoader.load(modelTypeUrl);
    </script>
    <div id="instructions_decorations">
      <div id="multiplier">x1</div>
      <div id="rotator"><svg viewbox="-30,-30,60,60"></svg></div>
      <canvas id="pli"></canvas>
      <script>
      var multiplier = document.getElementById("multiplier");
      updateMultiplier = function() {
        multiplier.innerHTML = "x" + currentMultiplier;
	multiplier.style.visibility = (currentMultiplier == 1) ? "hidden" : "visible";
	multiplier.style['margin-right'] = (currentMultiplier == 1) ? "-40px" : "0";
      }

      var rotator = document.getElementById("rotator");
      LDR.SVG.appendRotationCircle(0, 0, 18, rotator.childNodes[0]);
      updateRotator = function() {
	rotator.style.visibility = currentRotation ? "visible" : "hidden";
      }

      /*
        Icon: {x, y, width, height, mult, key, partID, colorID, desc}
       */
      function onPLIClick(e) {
        var x = e.layerX || e.clientX;
        var y = e.layerY || e.clientY;
	console.log("Click " + x +","+y);
	if(!pliClickMap)
	  return;
        // Find clicked icon:
	for(var i = 0; i < pliClickMap.length; i++) {
	  var icon = pliClickMap[i];
	  if(x >= icon.x && y >= icon.y && 
	     x <= icon.x+icon.width+5 &&
	     y <= icon.y+icon.height+12) {
	    // Correct icon found! Now show preview:
	    pliPreviewer.scene.remove(pliShownPreview);
	    var pc = pliBuilder.getPC(icon.key);
	    pliShownPreview = pc.mesh;
	    pliPreviewer.scene.add(pliShownPreview);
	    pliPreviewer.showPliPreview(icon);
	    var b = pc.getBounds();
	    var size = b.min.distanceTo(b.max) * 0.6;
	    pliPreviewer.subjectSize = size;
	    pliPreviewer.onResize();
	    
	    return;
	  }
	}
      }
      document.getElementById("pli").addEventListener('click', onPLIClick);
      </script>
    </div>

    <div id="pli_preview_section">
        <div id="preview_background" onclick="hidePliPreview();"></div>
        <div id="preview_holder">
          <div id="preview_parent"><canvas id="preview" /></div>
	  <div id="preview_info">
	    <span class="preview_info_line"><a href="" target="_blank"><div id="preview_info_name">PART NAME</div></a></span>
	    <span class="preview_info_line">LDraw color: <div id="preview_info_color_ldraw">LDR COLOR</div></span>
	    <span class="preview_info_line">LEGO/LDD color: <div id="preview_info_color_lego">LDD COLOR</div></span>
	  </div>
        </div>
    </div>
    
    <div id="green"></div>

    <div id="options" />
    <script>
    var optionsDiv = document.getElementById('options');
    ldrOptions.appendHeader(optionsDiv);    
    ldrOptions.appendOldBrickColorOptions(optionsDiv);
    //ldrOptions.appendLineOptions(optionsDiv);
    ldrOptions.appendContrastOptions(optionsDiv);
    ldrOptions.appendAnimationOptions(optionsDiv);
    ldrOptions.appendShowPLIOptions(optionsDiv);
    ldrOptions.appendLROptions(optionsDiv);
    ldrOptions.appendCameraOptions(optionsDiv);

    ldrOptions.appendFooter(optionsDiv);
    ldrOptions.listeners.push(function() {
      builder.updateMeshCollectors();
      updateUIComponents(true);
    });
    </script>
    </div>
  </body>
</html>

