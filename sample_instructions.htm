<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8" />
    <title>Sample Building Instructions</title>
    <link href="css/instructions.css" rel="stylesheet" type="text/css" />
    <link href="css/preview.css" rel="stylesheet" type="text/css">
    <link href="css/buttons.css" rel="stylesheet" type="text/css" />
    <link href="css/options.css" rel="stylesheet" type="text/css" />
    <!--<meta name="viewport" content="width=device-width" />-->
  </head>
  <body>
    <div id="pli_render_canvas"></div>
    <script src="js/jquery.min.js"></script>
    <script src="js/three.min.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/colors.js"></script>
    <script src="js/LDRShaders.js"></script>    
    <script src="js/LDRColorMaterials.js"></script>
    <script src="js/pli.js"></script>
    <script src="js/LDRSVG.js"></script>
    <script src="js/LDROptions.js"></script>
    <script src="js/ClientStorage.js"></script>
    <script src="js/LDRGeometries.js"></script>
    <script src="js/LDRLoader.js"></script>
    <script src="js/LDRStepBuilder.js"></script>
    <script src="js/LDRPartsBuilder.js"></script>
    <script src="js/RectanglePacking.js"></script>
    <script src="js/LDRPLIBuilder.js"></script>
    <script src="js/LDRPLIPreview.js"></script>
    <script src="js/LDRButtons.js"></script>
    <script src="js/LDRMeasurer.js"></script>
    <canvas id="main_canvas"></canvas>
    <script>
      var pageStartTime = new Date();
      //var modelTypeUrl = 'models/fail1.mpd';
      var modelTypeUrl = 'models/spiral.ldr';
      var scene = new THREE.Scene(); // To add stuff to
      scene.background = new THREE.Color( 0xFFFFFF );
      var storage;

      //scene.add( new THREE.AxesHelper( 5 ) );

      var defaultZoom = 1; // Will be overwritten.
      var currentStep = 1;
      var camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 1000000 ); // Orthographics for LEGO
      var pliW = 0, pliH = 0;
      var maxSizePerPixel = 1;

      function setBackgroundColor(c) {
        scene.background = new THREE.Color( parseInt("0x" + c) );
	document.body.style.backgroundColor = '#' + c;
      }

      var canvas = document.getElementById('main_canvas');
      var renderer = new THREE.WebGLRenderer({antialias: true, canvas:canvas});
      function render() {
        renderer.render(scene, camera);
      }
      document.body.appendChild(canvas);

      var ldrOptions = new LDR.Options();
      var ldrButtons = new LDR.Buttons(document.body, true, '1', null); // Use URL instead of null if available.
      var controls = new THREE.OrbitControls(camera, canvas);
      controls.noTriggerSize = 0.1;
      controls.addEventListener('change',render);

      var stats;
      //stats = new Stats(); document.body.appendChild(stats.dom);

      function resetCameraPosition() {
	camera.lookAt(new THREE.Vector3());
        updateViewPort();
        updateCameraZoom();
	render();
      }
      function zoomIn() {
        controls.dollyIn(1.2);
	render();
      }
      function zoomOut() {
        controls.dollyOut(1.2);
	render();
      }
      function updateCameraZoom(zoom) {
        zoom = zoom || defaultZoom;
	camera.zoom = zoom;
    	camera.updateProjectionMatrix();
      }

      resetCameraPosition();
      window.addEventListener('resize', onWindowResize, false);

      var adPeek = 120;
      var lastRefresh = new Date();
      
      function onWindowResize(){
        console.log("Resizing to " + window.innerWidth + ", " + window.innerHeight + " and device pixel ratio: " + window.devicePixelRatio);
        renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(window.innerWidth-20, window.innerHeight-adPeek);
        camera.left   = -canvas.clientWidth*0.95;
        camera.right  =  canvas.clientWidth*0.95;
        camera.top    =  canvas.clientHeight*0.95;
        camera.bottom = -canvas.clientHeight*0.95;
	
	updateViewPort();
        updateCameraZoom();
	if(builder) {
	  realignModel(0);
	  updateUIComponents(false);
	}
      }

      var currentRotationMatrix = new THREE.Matrix4(); 
      currentRotationMatrix.set(1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1);
      var defaultMatrix = new THREE.Matrix4();
      defaultMatrix.set(1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1);

      var ldrLoader;
      var builder = null;
      var pliElement;
      var pliClickMap; // All active pli's {pc, x, y, w, h}
      var pliBuilder;
      var pliShownPreview;

      var baseObject = new THREE.Group(), opaqueObject = new THREE.Group(), transObject = new THREE.Group();
      baseObject.add(opaqueObject); // Draw non-trans before trans.
      baseObject.add(transObject);
      scene.add(baseObject);
      var pliPreviewer = new LDR.PliPreviewer(); // TODO: Use model id as parameter if available.

      var showPLI = false;
      function updateUIComponents(force) {
      	  currentMultiplier = builder.getMultiplierOfCurrentStep();
      	  currentRotation = builder.getRotationOfCurrentStep();
	  updateMultiplier && updateMultiplier();
	  updateRotator && updateRotator();
	  setBackgroundColor(builder.getBackgroundColorOfCurrentStep());
	  if(builder.isAtVeryLastStep()) {
	    ldrButtons.atLastStep();
	  }
	  else if(builder.isAtFirstStep()) {
	    ldrButtons.atFirstStep();
	  }
  	  else {
	    ldrButtons.atAnyOtherStep();
	  }
	  ldrButtons.setShownStep(currentStep);
	  updatePLI(force);
          updateViewPort();
          updateCameraZoom();
	  render();
      }
      function updatePLI(force) {
	  var [step,stepColorID] = builder.getCurrentStepAndColor();
	  showPLI = ldrOptions.showPLI && step.containsPartSubModels(ldrLoader);
	  if(!showPLI) {
	    pliBuilder.pliElement.style.visibility = 'hidden';
	    pliW = pliH = 0;
	    return;
	  }
	  pliBuilder.pliElement.style.visibility = 'visible';

	  var maxWidth = window.innerWidth/window.devicePixelRatio;
	  var maxHeight = (window.innerHeight - 320 - adPeek)/window.devicePixelRatio; // icons, mult and rotator.

	  if(maxWidth >= maxHeight) {
	    pliClickMap = pliBuilder.drawPLIForStep(true, step, stepColorID, maxWidth*0.4, maxHeight, maxSizePerPixel*0.6, force);
	  }
	  else {
	    pliClickMap = pliBuilder.drawPLIForStep(false, step, stepColorID, maxWidth, maxHeight*0.4, maxSizePerPixel*0.6, force);
	  }
	  pliW = parseInt(pliElement.offsetWidth + pliElement.offsetLeft)+4; // 4 for border.
	  pliH = parseInt(pliElement.offsetHeight);
	  //console.log("Setting PLI size " + pliW + ", " + pliH + " from " + maxWidth + "/" + maxHeight + ", maxSizePerPixel=" + maxSizePerPixel + ', step=' + step);
      }
      function updateViewPort() {
          camera.position.set(10000, 7000, 10000);

	  if(pliBuilder && pliBuilder.fillHeight) {
	      controls.panTo(pliW/2, -30);
	  }
	  else {
	      controls.panTo(0, pliH/2 + (pliH > 0 ? 25 : 0));
	  }
      }

      var currentMultiplier = 1;
      var currentRotation = false;
      var updateMultiplier = null;
      var updateRotator = null;
      var initialConfiguration = true;
      function realignModel(stepDiff, onRotated, onDone) {
	  var oldRotationMatrix = currentRotationMatrix;
	  var oldPosition = new THREE.Vector3();
	  oldPosition.copy(baseObject.position);

	  // PLI:
	  var oldPLIW = pliW;
	  var oldPLIH = pliH;
	  var newPLIW, newPLIH;

	  var oldLevel = builder.getLevelOfCurrentStep();
	  var newLevel = oldLevel;
	  var goBack = function(){}; // Used for single steps
	  if(stepDiff === 1 && builder.nextStep(true)) {
	      goBack = function() {
	        newLevel = builder.getLevelOfCurrentStep();
	        builder.prevStep(true);
              };
	  }
	  else if(stepDiff === -1 && builder.prevStep(true)) {
	      goBack = function() {
	        newLevel = builder.getLevelOfCurrentStep();
	        builder.nextStep(true);
	      };
	  }

	  var viewPortWidth = window.innerWidth;
	  var viewPortHeight = window.innerHeight;
	  if(pliBuilder.fillHeight) {
	    viewPortWidth *= 0.6;
	    viewPortHeight -= adPeek+100;
	  }
	  else {
	    viewPortHeight *= 0.6;
	    viewPortHeight -= adPeek+160;
	  }

	  var useAccumulatedBounds = true;
	  var b = builder.getAccumulatedBounds();
	  var size = b.min.distanceTo(b.max);
	  var viewPortSize = Math.sqrt(viewPortWidth*viewPortWidth + viewPortHeight*viewPortHeight);
          //console.log("size=" + size + ", screen size=" + viewPortSize + ", size/screen=" + (size/viewPortSize));
	  if(size > viewPortSize) {
	    useAccumulatedBounds = false;
	    b = builder.getBounds();
	    size = b.min.distanceTo(b.max);
	    if(size < viewPortSize) {
	      var b2 = new THREE.Box3(); b2.copy(b); b = b2;
	      var bDiff = new THREE.Vector3(); bDiff.subVectors(b.max, b.min); // b.max-b.min
	      // Move min and max: max = min + bDiff -> min + bDiff/2 + (bDiff/2*X) = min + bDiff - bDiff/2 + (bDiff/2*X) = max + (X-1)*bDiff/2
	      bDiff.multiplyScalar(0.5*(viewPortSize/size-1));
	      b.max.add(bDiff);
	      b.min.sub(bDiff);
	      size = viewPortSize;
	    }
	  }
          var newPosition;
	  [newPosition, currentRotationMatrix] = builder.computeCameraPositionRotation(defaultMatrix, currentRotationMatrix, useAccumulatedBounds);

	  // Find actual screen bounds:
	  baseObject.setRotationFromMatrix(currentRotationMatrix);
	  baseObject.updateMatrixWorld(true);
	  var measurer = new LDR.Measurer(camera);
	  var [dx,dy] = measurer.measure(b, baseObject.matrixWorld);

	  // Update maxSizePerPixel:
	  if(dx*window.innerWidth/viewPortWidth > dy*window.innerHeight/viewPortHeight) {
	    maxSizePerPixel = size/viewPortWidth;
	  }
	  else {
	    maxSizePerPixel = size/viewPortHeight;
	  }
	  updatePLI(false); newPLIW = pliW, newPLIH = pliH;

	  goBack();
	  var rotationChanges = !currentRotationMatrix.equals(oldRotationMatrix);
	  var ignorePos = new THREE.Vector3(); // Ignore
	  var newRot = new THREE.Quaternion();
	  var ignoreScale = new THREE.Vector3(); // Ignore
	  currentRotationMatrix.decompose(ignorePos, newRot, ignoreScale);

	  var positionChanges = !oldPosition.equals(newPosition) || 
	      		      	oldPLIW !== newPLIW || oldPLIH !== newPLIH;

	  var oldDefaultZoom = defaultZoom;
	  viewPortWidth = window.innerWidth;
	  viewPortHeight = window.innerHeight;
	  if(pliBuilder.fillHeight) {
	    viewPortWidth -= newPLIW;
	    viewPortHeight -= adPeek+100;
	  }
	  else {
	    viewPortHeight -= adPeek+newPLIH+160;
	  }
	  var scaleX = window.innerWidth / viewPortWidth * 1.1; // 1.1 to scale down a bit
	  var scaleY = window.innerHeight / viewPortHeight * 1.1;
	  if(dx*scaleX > dy*scaleY) {
	    defaultZoom = 2*camera.zoom/(dx*scaleX);
	  }
	  else {
	    defaultZoom = 2*camera.zoom/(dy*scaleY);
	  }
	  var newDefaultZoom = defaultZoom;
	  var zoomChanges = oldDefaultZoom !== newDefaultZoom;

	  function finalize() {
	      initialConfiguration = false;
	      onRotated && onRotated(); onRotated = false;
    	      
	      baseObject.setRotationFromMatrix(currentRotationMatrix);
    	      baseObject.position.x = newPosition.x;
    	      baseObject.position.y = newPosition.y;
    	      baseObject.position.z = newPosition.z;
	      
	      defaultZoom = newDefaultZoom;
	      pliW = newPLIW;
	      pliH = newPLIH;
	      updateViewPort();
	      updateCameraZoom();
	      render();
	      onDone && onDone(); onDone = false;
	      if(new Date() - lastRefresh > 1000*60) {
                refreshCache();
		lastRefresh = new Date();
	      }
	  }
	  
	  var animationID;
	  var startTime = new Date();
	  var animationTimeRotationMS = rotationChanges ? (2-ldrOptions.showStepRotationAnimations)*300 : 0; // First rotate, 
	  var animationTimePositionMS = positionChanges ? (2-ldrOptions.showStepRotationAnimations)*150 : 0; // then move and zoom
	  if(stepDiff != 0 && newLevel !== oldLevel && newLevel-oldLevel === stepDiff) {
            animationTimeRotationMS = 0; // Don't rotate when stepping in.
	    animationTimePositionMS = 0;
	  }
	  var animationTimeMS = animationTimePositionMS+animationTimeRotationMS;
	  var lastPosition = oldPosition;
	  function animate() {
	      animationID = requestAnimationFrame(animate);

	      var diffMS = new Date() - startTime;
	      if(diffMS >= animationTimeMS) {
	          cancelAnimationFrame(animationID); 
		  finalize();
		  return; // Done.
	      }

	      var progress = diffMS / animationTimeMS;
	      defaultZoom = oldDefaultZoom + (newDefaultZoom-oldDefaultZoom)*progress;
	      pliW = oldPLIW + (newPLIW-oldPLIW)*progress;
	      pliH = oldPLIH + (newPLIH-oldPLIH)*progress;
	      updateViewPort();
	      updateCameraZoom();

	      if(diffMS < animationTimeRotationMS) { // Rotate first.
		  progress = diffMS/animationTimeRotationMS;

		  var oldPos = new THREE.Vector3();
		  var oldRot = new THREE.Quaternion();
		  var oldScale = new THREE.Vector3();
		  oldRotationMatrix.decompose(oldPos, oldRot, oldScale);
		  var angleToTurn = oldRot.angleTo(newRot);
		  oldRot.rotateTowards(newRot, angleToTurn*progress*1.1); // *1.1 Ensure it is fully turned.
		  
		  var invOldM4 = new THREE.Matrix4();
		  invOldM4.getInverse(oldRotationMatrix);
		  var tmpM4 = new THREE.Matrix4();
		  tmpM4.compose(oldPos, oldRot, oldScale);

		  oldPos.copy(oldPosition);
		  oldPos.negate();
		  oldPos.applyMatrix4(invOldM4);
		  oldPos.applyMatrix4(tmpM4);
		  oldPos.negate();
		  lastPosition = oldPos;
		  
    		  baseObject.setRotationFromMatrix(tmpM4);
    		  baseObject.position.x = oldPos.x;
    		  baseObject.position.y = oldPos.y;
    		  baseObject.position.z = oldPos.z;
	      }
	      else { // Move and zoom:
		  onRotated && onRotated(); onRotated = false;
		  progress = (diffMS-animationTimeRotationMS)/animationTimePositionMS;

		  var tmpPosition = new THREE.Vector3();
		  tmpPosition.subVectors(newPosition, lastPosition).multiplyScalar(progress).add(lastPosition);
		  
		  // Update camera and baseObject:
    		  baseObject.position.x = tmpPosition.x;
    		  baseObject.position.y = tmpPosition.y;
    		  baseObject.position.z = tmpPosition.z;
	      }

	      render();
	      stats && stats.update();
          }

	  // Only animate if:
	  if(ldrOptions.showStepRotationAnimations < 2 && // show animations
	     Math.abs(stepDiff) === 1 && // Only stepping a single step &&
	     !initialConfiguration && // This is not the initial step &&
	     (zoomChanges || rotationChanges || positionChanges)) {
	    animate();
	  }
	  else {
	    finalize();
	  }
      }

      var windowStepCauseByHistoryManipulation = false;
      var baseURL = 'sample_instructions.htm?step='; //"r.php?model=1&color=0&step=";

      // Ensure mobile users can swipe right for next step:
      var ensureSwipeForwardWorks = function() {
	window.history.replaceState(currentStep, null, baseURL + currentStep);
        if(currentStep != builder.totalNumberOfSteps) {
          window.history.pushState(currentStep+1, null, baseURL + (currentStep+1));
	  windowStepCauseByHistoryManipulation = true;
	  window.history.go(-1); // Go back again.
	}
      }

      function clampStep(s) {
        if(s < 1)
	  return 1;
	if(s > builder.totalNumberOfSteps)
	  return builder.totalNumberOfSteps;
	return s;
      }

      var accHelper, helper;
      var handleStepsWalked = function(walkedSteps){
        // Helper. Uncomment next lines for step bounding boxes:
	/*if(helper)
	  builder.baseObject.remove(helper);
	if(accHelper)
	  builder.baseObject.remove(accHelper);
	accHelper = new THREE.Box3Helper(builder.getAccumulatedBounds(), 0x00FF00)
	helper = new THREE.Box3Helper(builder.getBounds(), 0xFFCC00)
	builder.baseObject.add(accHelper);
	builder.baseObject.add(helper);//*/

	currentStep = clampStep(currentStep + walkedSteps);
	ensureSwipeForwardWorks();
	if(walkedSteps != 1 && walkedSteps != -1)
	  realignModel(0);
	updateUIComponents(false);
	render();
      };
      function goToStep(step) {
        if(pliShownPreview)
	  return; // Don't walk when showing stuff.

	step = clampStep(step);
	var diff = step-currentStep;
	console.log("Going to " + step + " from " + currentStep);
	builder.moveSteps(step-currentStep, handleStepsWalked);
      }
      function nextStep() {
        if(pliShownPreview)
	  return; // Don't walk when showing stuff.
        if(builder.isAtVeryLastStep())
	  return;

	realignModel(1, function(){
            builder.nextStep(false);	      
	}, function() {
	    handleStepsWalked(1, false);
	});
      }
      function prevStep() {
        if(pliShownPreview)
	  return; // Don't walk when showing stuff.
	if(builder.isAtFirstStep())
	  return;

	realignModel(-1, function(){
          builder.prevStep(false);
	}, function() {
	  handleStepsWalked(-1, false);
	});
      }

      // Make ldrButtons catch arrow keys left/right
      document.onkeydown = handleKeyDown;
      function handleKeyDown(e) {
          e = e || window.event;
	  if(e.altKey) {
	    // Don't handle key events when ALT is pressed, as they indicate page shift overwrite!
	    return;
	  }
	  if(e.keyCode == '13') { // ENTER
	    var stepToGoTo = parseInt(ldrButtons.stepInput.value);
	    goToStep(stepToGoTo);
	  }
	  else if(e.keyCode == '37') { // Left:
	    prevStep();
          }
	  else if (e.keyCode == '39') { // Right:
            nextStep();
          }
	  else if(e.keyCode == '27') { // ESC closes preview.
	    hidePliPreview();
            hideDone();
          }
      }
      
      function hidePliPreview() {
	    pliPreviewer.hidePliPreview();
	    pliPreviewer.scene.remove(pliShownPreview);
	    pliShownPreview = null;
      }
	
      function hideDone() {
        var fadeOutTime = 400;
        $('#done_holder, #done_background').fadeOut(fadeOutTime);
      }
      var doneShown = false;
      function clickDone() {
        console.log("Showing done");
        var fadeInTime = 400;
        $('#done_holder, #done_background').fadeIn(fadeInTime);
	if(doneShown)
	  return;
	doneShown = true;
	$('#done_holder').load('ajax/done.php', {model:'1'});
      }
	
      var onPartsRetrieved = function(ignoreWhatIsStillToBeBuilt) {
        console.log("Done loading at " + (new Date()-pageStartTime) + "ms.");
	var mainModel = ldrLoader.mainModel;
	var origo = new THREE.Vector3();
	var inv = new THREE.Matrix3(); 
      	inv.set(1,0,0, 0,1,0, 0,0,1); // Invert Y-axis

	var pd = new THREE.LDRPartDescription(0, origo, inv, mainModel, false);

	pliElement = document.getElementById('pli');
	pliBuilder = new LDR.PLIBuilder(ldrLoader,
		     	                mainModel,
					0, 
		                        pliElement,
					document.getElementById('pli_render_canvas'));
        builder = new LDR.StepBuilder(opaqueObject, transObject, ldrLoader, [pd], true, storage);
	builder.nextStep(false);
	realignModel(0);
	updateUIComponents(false);
	render(); // Updates background color.

        console.log("Render done after " + (new Date()-pageStartTime) + "ms.");

	// Go to step indicated by parameter:
	var stepFromParameters = 1;
	stepFromParameters = clampStep(stepFromParameters);
	if(stepFromParameters > 1)
	  builder.moveSteps(stepFromParameters-1, handleStepsWalked);
	else
	  ensureSwipeForwardWorks();

	// Register location changes:
	window.addEventListener('popstate', function(e) {
	  var step = e.state;
	  if(windowStepCauseByHistoryManipulation || step === null) {
	    //console.log("Ignoring history manipulating step to: " + step);
	    windowStepCauseByHistoryManipulation = false;
            return;
	  }
	  var diff = step - currentStep;
  	  //console.log("Step from window: " + step + ", diff: " + diff);
	  if(diff === 1) {
	      nextStep();
	  }
	  else if(diff === -1) {
	      prevStep();
	  }
	  else {
            var handleStepsWalkedNoHistoryChange = function(walkedSteps){
	      currentStep = clampStep(currentStep + walkedSteps);
	      ensureSwipeForwardWorks();
	      realignModel(0);
	      updateUIComponents(false);
            };
	    builder.moveSteps(diff, handleStepsWalkedNoHistoryChange);
	  }
        });

	// Enable pli preview:
        pliPreviewer.attachRenderer(document.getElementById('preview'));
      }

      var onLoad = function() {
	function onStorageReady() {
  	  var geometryBuilder = new LDR.GeometryBuilder(ldrLoader, storage);
	  var toBeBuilt = geometryBuilder.getAllTopLevelToBeBuilt();

	  if(storage.db) {
	    storage.retrievePartsFromStorage(toBeBuilt, onPartsRetrieved);
	  }
	  else {
	    onAllToBeBuiltIdentified(toBeBuilt);
	  }
	}
 	storage = new LDR.STORAGE(onStorageReady);
      }

      onWindowResize();
      LDR.Colors.canBeOld = true;
      ldrLoader = new THREE.LDRLoader(onLoad);
      ldrLoader.load(modelTypeUrl);
    </script>
    <div id="instructions_decorations">
      <div id="multiplier">x1</div>
      <div id="rotator"><svg viewbox="-30,-30,60,60"></svg></div>
      <canvas id="pli"></canvas>
      <script>
      var multiplier = document.getElementById("multiplier");
      updateMultiplier = function() {
        multiplier.innerHTML = "x" + currentMultiplier;
	multiplier.style.visibility = (currentMultiplier == 1) ? "hidden" : "visible";
	multiplier.style['margin-right'] = (currentMultiplier == 1) ? "-40px" : "0";
      }

      var rotator = document.getElementById("rotator");
      LDR.SVG.appendRotationCircle(0, 0, 18, rotator.childNodes[0]);
      updateRotator = function() {
	rotator.style.visibility = currentRotation ? "visible" : "hidden";
      }

      /*
        Icon: {x, y, width, height, mult, key, partID, colorID, desc, inlined}
       */
      function onPLIClick(e) {
        var x = e.layerX || e.clientX;
        var y = e.layerY || e.clientY;
	console.log("Click " + x +","+y);
	if(!pliClickMap)
	  return;
        // Find clicked icon:
	for(var i = 0; i < pliClickMap.length; i++) {
	  var icon = pliClickMap[i];
	  if(x >= icon.x && y >= icon.y && 
	     x <= icon.x+icon.width+5 &&
	     y <= icon.y+icon.height+12) {
	    // Correct icon found! Now show preview:
	    pliPreviewer.scene.remove(pliShownPreview);
	    var pc = pliBuilder.getPC(icon.key);
	    pliShownPreview = pc.mesh;
	    pliPreviewer.scene.add(pliShownPreview);
	    pliPreviewer.showPliPreview(icon);
	    var b = pc.getBounds();
	    var size = b.min.distanceTo(b.max) * 0.6;
	    pliPreviewer.subjectSize = size;
	    pliPreviewer.onResize();
	    
	    return;
	  }
	}
      }
      document.getElementById("pli").addEventListener('click', onPLIClick);

      function refreshCache() {
        console.log("Refresh cache");
      }

      </script>
    </div>

    <div id="pli_preview_section">
        <div id="preview_background" onclick="hidePliPreview();"></div>
        <div id="preview_holder">
          <div id="preview_parent"><canvas id="preview" /></div>
	  <div id="preview_info">
	    <span class="preview_info_line">
	     <span id="preview_info_name">PART NAME</span>
	     <a id="preview_info_bh_link" href="" target="_blank">Go to part</a>
	     or
	     <a id="preview_info_bl_link" href="" target="_blank">See on BrickLink</a>
            </span>
	    <span class="preview_info_line">LDraw color: <div id="preview_info_color_ldraw">LDR COLOR</div></span>
	    <span class="preview_info_line">LEGO/LDD color: <div id="preview_info_color_lego">LDD COLOR</div></span>
	  </div>
        </div>
    </div>
    
    <div id="done_section">
        <div id="done_background" onclick="hideDone();"></div>
        <div id="done_holder">
        </div>
    </div>

    <div id="green"></div>

    <div id="options" />
    <script>
    var optionsDiv = document.getElementById('options');
    ldrOptions.appendHeader(optionsDiv);    
    ldrOptions.appendOldBrickColorOptions(optionsDiv);
    //ldrOptions.appendLineOptions(optionsDiv);
    ldrOptions.appendContrastOptions(optionsDiv);
    ldrOptions.appendAnimationOptions(optionsDiv);
    ldrOptions.appendShowPLIOptions(optionsDiv);
    ldrOptions.appendLROptions(optionsDiv);
    ldrOptions.appendCameraOptions(optionsDiv);

    ldrOptions.appendFooter(optionsDiv);
    ldrOptions.listeners.push(function() {
      builder.updateMeshCollectors();
      updateUIComponents(true);
    });
    </script>
    </div>
  </body>
</html>

